# OS_Lab4

## Q1

در هنگام قفل شدن و اجرای ناحیه بحرانی وقفه ها غیر فعال میشود و تا تمام نشدن کد های ناحیه بحرانی غیر فعال میماند زیرا ممکن است وقفه پیش آمده از همان حافظه مشترک با ناحیه بحرانی استفاده کند و باعث اختلال در برنامه شود. به طور کلی با دو روش کنترل از پردازه فعلی هنگام اجرای ناحیه بحرانی گرفته میشود.در حالت اول خود پردازه پردازنده را ازاد کند و یا وقفه باعث از دست دادن کنترل بشود. هر دوی این اتفاق ها نیاز است که مدیریت شوند . جلوگیری از وفقه داخلی آسان است اما برای حالت دوم نیاز داریم که وقفه ها را موقتا متوقف کنیم.هنگام رسیدن وقفه در هنگام اجرای ناحیه بحرانی. مدیر وقفه سعی میکند که همان قفل پردازه فعلی را تصاحب کند اما پردازه در حال حاضر دارای قفل است و باعث توقف موقت وقفه میشود.با غیر فعال کردن وقفه قدرت تعویض متن از پردازه نیز گرفته میشود و تضمین میکند که هیچ پردازه دیگری از این حافظه مشترک در اختیار پردازه فعلی استفاده نکند.

#### pushcli popcli

دو تابعی هستند که برای غیرفعال و فعال کردن وقفه استفاده میشوند.به طوری که به صورت زوج عمل کرده و با هر پوش قطعا یک پاپ نیز استفاده میشود اما برای
cli sli این ضرورت وجود ندارد

## Q2

در استفاده از acquiresleep و releasesleep یک ساختار جدید به نام sleeplock‌ داریم که محتویات آن به صورت زیر است :
lk: یک spinlock که برای محافظت از قفل استفاده می‌شود (دو پراسس همزمان وضعیت قفل را تغییر ندهند.)
locked: نشان می‌دهد که آیا قفل درحال حاضر در دست یک پراسس است یا آزاد است.
name: اسم قفل که بیشتر برای دیباگ به کار می‌آید
pid: پراسسی که در حال حاضر قفل را در دست دارد نشان می‌دهد.
هر بار که ما acquiresleep را برای یک sleeplock صدا می‌زنیم، ابتدا قفل چرخشی محافظتی مربوط به آن sleeplock فعال می‌شود و سپس بررسی می‌شود اگر قفل آزاد بود گرفته شود(مقدار locked برابر ۱ شود) و در صورتی که آزاد نباشد تابع sleep صدا زده می‌شود که در آن ابتدا قفل محافظتی از پراسس گرفته می‌شود و سپس وضعیت پراسس به SLEEPING‌ تغییر کرده و متغیر chan از پراسس برابر sleeplock‌ موردنظر است که نشان می‌دهد پراسس منتظر آزاد شدن این lock می‌باشد. در نهایت برنامه به زمانبند داده می‌شود تا پراسس دیگری وارد شود. پراسس زمانی بیدار می‌شود که قف آزاد شده باشد.
در releasesleep به طور مشابه قفل محافظتی را به دست میگیریم و سپس قفل را آزاد می‌کنیم (locked به ۰ تغییر می‌کند) و سپس تابع wakeup صدا زده می‌شود. در این تابع ما بر روی تمام پراسس‌ها حلقه می‌زنیم و اولین پراسس خوابی را پیدا می‌کنیم که در انتظار قفل آزاد شده باشد و وضعیت این پراسس را از حالت SLEEPING‌ به RUNNABLE تغییر می‌دهیم تا اجرا شود.
علت آن که نمی‌توان از spinlock در مساله‌ی تولید‌کننده/مصرف‌کننده استفاد کرد این است که در این مساله علاوه بر آن که دو پراسس نباید به طور همزمان به اطلاعات مشترک دسترسی پیدا کنند،‌ باید به خالی و پر بودن بافر نیز توجه شود. برای مثال حالتی را در نظر میگیریم که بافر خالی است و مصرف‌کننده می‌خواهد از از آن استفاده کند و در نتیجه در حالت busy waiting قرار می‌گیرد و اگر در همین حالت تولید‌کننده بخواهد چیزی را درون بافر قرار دهد مجبور می‌شود بی هیچ علتی صبر کند تا کار پراسس مصرف‌کننده تمام شود. به طور مشابه می‌توان این حرف را در حالت پر بودن بافر نیز زد.

## Q3

پردازه ها 6 حالت متفاوت دارند ( (UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE
RUNNING: یک پردازنده به پردازه اختصاص داده شده و در حال اجرا است.
RUNNABLE: پردازه در صف انتظار است تا یک پردازنده به ان اختصاص داده شود.
ZOMBIE: پدر این پردازه تمام شده یا کشته شده اما این پردازه از بین نرفته است.
SLEEPING: پردازه روی یک کانال ( مثلا io ) خوابیده و منتظر جواب از آن کانال است.
EMBRYO: این وضعیت برای زمانی است که یک پردازه جدید allocproc میشود برای اینکه بقیه نتوانند روی آن کار کنند وضعیتش از UNUSED به EMBRYO تغییر میکند و بعد از اتمام فرایند ایجاد به حالت RUNNABLE میرود
UNUSED: هنوز از این پردازه استفاده ای نشده و برنامه ای به آن داده نشده است.
وظیفه تابع sched پیدا کردن پردازه کاندید بعدی برای اجرا توسط cpu است.

## Q4

برای رفع مشکل ازاد سازی توسط پردازه ای غیر از کسی که آن را در اختیار گرفته است، کافی ایست یک متغیر owner که Int باشد در نظر بگیریم و بعد از اینکه پردازه ای acquiresleep را فراخوانی کرد مقدار owner را برابر ایدی پردازه فعلی قرار دهیم و در متد releasesleep برابری ایدی پردازه فعلی و owner را بررسی کنیم. دقت شود چون این روش mutual exclusion را تضمین میکند تنها یک پردازه مقدار owner را به روز میکند و race condition نداریم. در لینوکس این فرایند توسط قفل mutex انجام میشود.

## Q5

در حافظه های تراکنشی تعدادی دستور read, write به صورت atomic اجرا شده و تنها زمانی تغییرات روی حافظه ذخیره می شود که تمام دستور ها با موفقیت انجام شوند در غیر این صورت تمام تغییرات بازگردانده میشود و حافظه دست نخورده باقی می ماند. این قابلیت با atomic کردن مجموعه از دستورات (که می تواند ناحیه بحرانی باشد) از اجرای همزمان آنها جلوگیری کرده و یکی حتما زودتر اجرا میشود بدین ترتیب نیازی به lock برای حفظ کردن mutual exclusion نداریم. همچنین یک سیستم حافظه تراکنشی می تواند تشخیص دهد که کدام دستور ها امکان اجرای همزمان را دارند بنابراین میتواند ناحیه بحرانی یک پارچه ما را به نواحی بحرانی کوچکتر تقسیم کند که باعث بهبود سرعت اجراست.
